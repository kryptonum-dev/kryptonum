---
import type { HTMLAttributes } from 'astro/types'

type Props = HTMLAttributes<'span'>

const { ...props } = Astro.props

const value = await Astro.slots.render('default')
---

<p {...props} data-count-up>{value}</p>

<script>
  const DURATION = 2500

  // 1) European decimal (e.g. 18,03) – comma + 1–2 decimal digits
  // 2) Thousands (e.g. 1,500,000 or 1 500 000)
  // 3) Plain number with optional dot decimals (e.g. 18.03 or 42)
  const NUMBER_PATTERN = /(\d+,\d{1,2}(?=\D|$)|\d{1,3}(?:[,\s]\d{3})+(?:\.\d+)?|\d+(?:\.\d+)?)/

  const easeOutQuint = (x: number) => 1 - Math.pow(1 - x, 5)

  function parseNumericValue(str: string) {
    let thousandsSeparator = ''
    let decimalSeparator = '.'
    let clean = str

    // European decimal comma (e.g. 18,03)
    if (/^\d+,\d{1,2}$/.test(str.trim())) {
      decimalSeparator = ','
      clean = str.replace(',', '.')
    } else if (/\d,\d{3}/.test(str)) {
      thousandsSeparator = ','
      clean = str.replace(/,/g, '')
    } else if (/\d\s\d{3}/.test(str)) {
      thousandsSeparator = ' '
      clean = str.replace(/\s/g, '')
    }

    const value = parseFloat(clean)
    const decMatch = clean.match(/\.(\d+)$/)
    const decimals = decMatch ? decMatch[1].length : 0

    return { value: isNaN(value) ? 0 : value, thousandsSeparator, decimalSeparator, decimals }
  }

  function formatNumber(num: number, thousandsSeparator: string, decimalSeparator: string, decimals: number): string {
    const str = decimals > 0 ? num.toFixed(decimals) : Math.floor(num).toString()
    const [intPart, decPart] = str.split('.')
    const grouped = thousandsSeparator
      ? intPart.replace(/\B(?=(\d{3})+(?!\d))/g, thousandsSeparator)
      : intPart
    return decPart !== undefined ? `${grouped}${decimalSeparator}${decPart}` : grouped
  }

  function animateNumber(element: HTMLElement): void {
    const originalText = element.textContent || '0'
    const { value, thousandsSeparator, decimalSeparator, decimals } = parseNumericValue(originalText)
    if (value === 0) return

    let start: number
    const step = (timestamp: number) => {
      if (!start) start = timestamp
      const progress = Math.min((timestamp - start) / DURATION, 1)
      const current = easeOutQuint(progress) * value

      if (progress < 1) {
        element.textContent = formatNumber(current, thousandsSeparator, decimalSeparator, decimals)
        requestAnimationFrame(step)
      } else {
        element.textContent = originalText
      }
    }
    requestAnimationFrame(step)
  }

  function prepareElement(element: HTMLElement): void {
    const text = element.textContent || ''
    const initialWidth = element.getBoundingClientRect().width
    element.style.width = `${initialWidth}px`

    const parts = text.split(NUMBER_PATTERN)
    element.innerHTML = parts
      .map((part) => (NUMBER_PATTERN.test(part) ? `<span class="number">${part}</span>` : part))
      .join('')
  }

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(({ isIntersecting, target }) => {
      if (isIntersecting) {
        const el = target as HTMLElement
        el.querySelectorAll<HTMLElement>('.number').forEach((num) => animateNumber(num))
        setTimeout(() => { el.style.width = '' }, DURATION)
        observer.unobserve(el)
      }
    })
  })

  document.querySelectorAll<HTMLElement>('[data-count-up]').forEach((el) => {
    prepareElement(el)
    observer.observe(el)
  })
</script>
